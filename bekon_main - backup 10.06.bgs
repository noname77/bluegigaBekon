dim result
dim endpoint
dim in(20) # endpoint data in
dim in_len
dim out(20) # endpoint data out
dim out_len
dim connected
dim write_data

const SET_DATA = 1
const GET_DATA = $7a78
const SERIAL_LINE = $7373
dim write_serial
const END_SERIAL = $0a #lf  atm, change it

const PACKET_SIZE = 20

#holds data to transfer when requested
dim data1(25)
dim data1_len
dim data1_left_to_send
dim data1_curr_len
dim data1_send
dim data2(50)

dim custom_adv_data(9)

event system_boot(major, minor, patch, build, ll_version, protocol_version, hw)
    
	write_serial = 0
	write_data = 0
	connected = 0
	data1_len = 25
	data1_send = 0
	
	data1(0:1) = $45
	data1(1:1) = $47
	data1(2:1) = $45
	data1(3:1) = $47
	data1(4:1) = $45
	data1(5:1) = $47
	data1(6:1) = $45
	data1(7:1) = $47
	data1(8:1) = $45
	data1(9:1) = $47
	data1(10:1) = $45
	data1(11:1) = $47
	data1(12:1) = $45
	data1(13:1) = $47
	data1(14:1) = $45
	data1(15:1) = $47
	data1(16:1) = $45
	data1(17:1) = $47
	data1(18:1) = $45
	data1(19:1) = $47
	data1(20:1) = $45
	data1(21:1) = $47
	data1(22:1) = $45
	data1(23:1) = $47
	data1(24:1) = $45
	data1(25:1) = $47
	
    endpoint = system_endpoint_uart1
    
    call system_endpoint_tx(endpoint, 15, "BLE booted up\n\r")

    call system_endpoint_set_watermarks(endpoint, 0, 0) # disable watermarks
    
	#TODO: something with custom adv
    custom_adv_data(0:1) = $04 #Length of adv data
    custom_adv_data(1:1) = $ff #AD type is Manufacturer Specific Data AD type
    custom_adv_data(2:1) = $47 #Bluegiga Company Identifier Code - octet 2
    custom_adv_data(3:1) = $00 #Bluegiga Company Identifier Code - octet 1
    custom_adv_data(4:1) = $e5 #Custom data indicating other side that we support spp_over_ble - or use line below
    #custom_adv_data(4:1) = $e6 #Custom data indicating a remote bled112 to reboot in dfu mode
    custom_adv_data(5:1) = $03 #Length of next adv data
    custom_adv_data(6:1) = $09 # AD type is Complete local name
    custom_adv_data(7:1) = $45 #E
    custom_adv_data(8:1) = $54 #T
    call gap_set_adv_data(1, 9, custom_adv_data(0:9)) #overwrites the friendly name in gatt.xml with ET but also allows closed system's companion module-dongle to automatically connect
    call gap_set_mode(gap_user_data, gap_undirected_connectable)
    
	
end

event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
    
    call system_endpoint_tx(endpoint, 17, "Connected to: ")
	call system_endpoint_tx(endpoint, 6, address(0:6))
	call system_endpoint_tx(endpoint, 1, "\n")
    call system_endpoint_tx(endpoint, 15, "Connection id: ")
    call system_endpoint_tx(endpoint, 1, connection)
    call system_endpoint_tx(endpoint, 1, "\n")	
    call system_endpoint_tx(endpoint, 26, "Connection interval: ")
    call system_endpoint_tx(endpoint, 2, conn_interval)
    call system_endpoint_tx(endpoint, 1, "\n")
    
end

event attributes_status(handle, flags)

    if (handle = xgatt_serial) && (flags = 2) then
    
       call system_endpoint_tx(endpoint, 52, "Local CCC set by remote side to start indications.\n\r")
       call system_endpoint_tx(endpoint, 38, "Transparent data exchange can start.\n\r")

       call system_endpoint_set_watermarks(endpoint, 1, 0) # set RX watermark
    
    end if

end

event system_endpoint_watermark_rx(curr_endpoint, size)
#TODO: add command support (change data to be sent)
    in_len = size
    if in_len > 20 then
       in_len = 20
    end if
    call system_endpoint_set_watermarks(endpoint, 0, $ff) # disable RX watermark
    call system_endpoint_rx(endpoint, in_len)(result, in_len, in(0:in_len))
	if in(0:2) = SERIAL_LINE then
		write_serial = 1
		in_len = in_len - 2
		in(0:in_len) = in(2:(in_len+2))
	end if
	
	if in(0:2) = END_SERIAL then
		write_serial = 0
	end if
	
	if write_serial = 1 then
		call attributes_write(xgatt_serial, 0, in_len, in(0:in_len))
    end if
end

event attclient_indicated(connection, handle)

    if handle = xgatt_serial then
        call system_endpoint_set_watermarks(endpoint, 1, $ff) # set RX watermark
    end if
	
	if data1_left_to_send < PACKET_SIZE && handle = xgatt_data1 then
		data1_curr_len = data1_left_to_send
	end if
	
	if data1_left_to_send >= PACKET_SIZE && handle = xgatt_data1 then
		data1_curr_len = PACKET_SIZE
	end if
	
    if handle = xgatt_data1 && data1_send then
		#send more data while there is data to be sent
		call attributes_write(xgatt_data1, (data1_len - data1_left_to_send), data1_curr_len, data1(0:data1_len))
		data1_left_to_send = data1_left_to_send - data1_curr_len
	end if
	
	if data1_left_to_send = 0 && handle = xgatt_data1 then
		data1_send = 0
	end if
		
	
end

event attributes_value(connection, reason, handle, offset, value_len, value_data)
	if value_data(0:2) = GET_DATA then
		write_data = handle
		call system_endpoint_set_watermarks(endpoint, $ff, 2) # set TX watermark
		call system_endpoint_tx(endpoint, 10, "Got data: ")
		call system_endpoint_tx(endpoint, 2, value_data(0:2))
		call system_endpoint_tx(endpoint, 10, "\n\r")
	end if
	
    if handle = xgatt_serial then
        out(0:value_len) = value_data(0:value_len)
        out_len = value_len
        call system_endpoint_set_watermarks(endpoint, $ff, out_len) # set TX watermark
    end if
    
	if data1_len < PACKET_SIZE && write_data = xgatt_data1 then
		data1_left_to_send = 0
		data1_send = 0
		data1_curr_len = data1_len
	end if
	
	if data1_len >= PACKET_SIZE && write_data = xgatt_data1 then
		data1_left_to_send = data1_len - PACKET_SIZE
		data1_curr_len = PACKET_SIZE
		data1_send = 1
	end if
	
	if write_data = xgatt_data1 then
		
		call attributes_write(xgatt_data1, 0, data1_curr_len, data1(0:data1_len))
	end if
end

event system_endpoint_watermark_tx(curr_endpoint, size)

    if curr_endpoint = endpoint then
        call system_endpoint_set_watermarks(endpoint, $ff, 0) # disable TX watermark
        call system_endpoint_tx(endpoint, out_len, out(0:out_len))
        call attributes_user_write_response(0, 0)
    end if
    
end

event connection_disconnected(conn, reas)
    
    call system_endpoint_tx(endpoint, 29, "Disconnected. connection id: ")
	call system_endpoint_tx(endpoint, 1, conn)
	call system_endpoint_tx(endpoint, 1, "\n")
    call system_endpoint_tx(endpoint, 17, "Reason code: ")
    call system_endpoint_tx(endpoint, 2, reas)
    call system_endpoint_tx(endpoint, 1, "\n")

    call system_endpoint_set_watermarks(endpoint, 0, 0) # disable watermarks
    
    call gap_set_adv_data(1, 9, custom_adv_data(0:9))
    call gap_set_mode(gap_user_data, gap_undirected_connectable)
    
end
